import{_ as a,c as i,o as t,a6 as s}from"./chunks/framework.CHl2ywxc.js";const h=JSON.parse('{"title":"Phase 9 — Comprehensive Testing Architecture","description":"","frontmatter":{},"headers":[],"relativePath":"testing/phase-9-testing-architecture.md","filePath":"testing/phase-9-testing-architecture.md","lastUpdated":1755281500000}'),n={name:"testing/phase-9-testing-architecture.md"};function o(l,e,r,c,d,p){return t(),i("div",null,e[0]||(e[0]=[s(`<h1 id="phase-9-—-comprehensive-testing-architecture" tabindex="-1">Phase 9 — Comprehensive Testing Architecture <a class="header-anchor" href="#phase-9-—-comprehensive-testing-architecture" aria-label="Permalink to &quot;Phase 9 — Comprehensive Testing Architecture&quot;">​</a></h1><p>This document specifies the end-to-end testing architecture for the Master MCP Server across Node.js and Cloudflare Workers. It is tailored to this codebase (TypeScript, ESM, strict mode) and builds on Phases 1–8 (auth, module loading, routing, config, OAuth, utils).</p><h2 id="goals" tabindex="-1">Goals <a class="header-anchor" href="#goals" aria-label="Permalink to &quot;Goals&quot;">​</a></h2><ul><li>Cross-platform: Node 18+ and Cloudflare Workers.</li><li>ESM + TypeScript strict compatibility.</li><li>Leverage existing utilities (logging, validation, monitoring).</li><li>Clear test layering: unit, integration, E2E, plus security and performance.</li><li>Deterministic, isolated, and parallel-friendly test runs.</li><li>CI/CD automation with quality gates and coverage thresholds.</li></ul><hr><h2 id="framework-selection" tabindex="-1">Framework Selection <a class="header-anchor" href="#framework-selection" aria-label="Permalink to &quot;Framework Selection&quot;">​</a></h2><ul><li><p>Unit/Integration (Node): Vitest</p><ul><li>Fast, ESM-native, TS-friendly. Built-in mock timers and coverage via V8.</li><li>Supertest for Express-based HTTP integration of Node runtime (<code>src/index.ts</code>).</li><li>Undici MockAgent (optional) for fetch interception on Node 18, when not spinning stub servers.</li></ul></li><li><p>Unit/Integration (Workers): Vitest + Miniflare 3</p><ul><li><code>miniflare</code> test environment for <code>Request</code>/<code>Response</code> compatibility.</li><li>Target <code>OAuthFlowController.handleRequest</code> and any worker entrypoints (<code>src/runtime/worker.ts</code>).</li></ul></li><li><p>E2E (HTTP-level): Vitest test suite using real HTTP listeners</p><ul><li>Node: start Express via <code>createServer(true)</code> and use Supertest/HTTP.</li><li>Workers: run Miniflare instance or <code>wrangler dev</code> in CI as needed.</li></ul></li><li><p>Performance: Artillery</p><ul><li>Simple YAML scenarios to stress authentication and routing endpoints.</li><li>Separate CI job; can be run locally against dev servers.</li></ul></li><li><p>Security: Vitest + fast-check (property-based) + static assertions</p><ul><li>Fuzz inputs for token parsing, state/PKCE validation, and router input validation.</li><li>Optional OWASP ZAP baseline in CI (nightly) if desired.</li></ul></li></ul><hr><h2 id="directory-structure" tabindex="-1">Directory Structure <a class="header-anchor" href="#directory-structure" aria-label="Permalink to &quot;Directory Structure&quot;">​</a></h2><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>tests/</span></span>
<span class="line"><span>  unit/</span></span>
<span class="line"><span>    routing/              # circuit-breaker, retry, load-balancer</span></span>
<span class="line"><span>    modules/              # aggregator, router (with fetch mocked)</span></span>
<span class="line"><span>    oauth/                # pkce/state/validator</span></span>
<span class="line"><span>    utils/                # logger, validation helpers</span></span>
<span class="line"><span>  integration/</span></span>
<span class="line"><span>    node/                 # express endpoints, config manager wiring</span></span>
<span class="line"><span>    workers/              # flow-controller.handleRequest via Miniflare</span></span>
<span class="line"><span>    oauth/                # callback flow with mock OIDC provider</span></span>
<span class="line"><span>  e2e/</span></span>
<span class="line"><span>    node/                 # start full HTTP server and hit /mcp/*, /oauth/*</span></span>
<span class="line"><span>    workers/              # worker entrypoint end-to-end</span></span>
<span class="line"><span>  mocks/</span></span>
<span class="line"><span>    oauth/                # mock OIDC provider (Node + Worker variants)</span></span>
<span class="line"><span>    mcp/                  # fake MCP backends (capabilities/tools/resources)</span></span>
<span class="line"><span>    http/                 # undici MockAgent helpers (Node)</span></span>
<span class="line"><span>  factories/</span></span>
<span class="line"><span>    configFactory.ts      # MasterConfig, ServerConfig builders</span></span>
<span class="line"><span>    oauthFactory.ts       # tokens/states/JWKS</span></span>
<span class="line"><span>    mcpFactory.ts         # tool/resource definitions</span></span>
<span class="line"><span>  fixtures/</span></span>
<span class="line"><span>    capabilities.json</span></span>
<span class="line"><span>    tools.json</span></span>
<span class="line"><span>    resources.json</span></span>
<span class="line"><span>  perf/</span></span>
<span class="line"><span>    artillery/</span></span>
<span class="line"><span>      auth-routing.yaml   # load scenarios for auth + routing</span></span>
<span class="line"><span>  security/</span></span>
<span class="line"><span>    oauth.spec.ts         # PKCE/state/nonce fuzz tests (fast-check)</span></span>
<span class="line"><span>  _setup/</span></span>
<span class="line"><span>    vitest.setup.ts       # global hooks, silent logs, fake timers config</span></span>
<span class="line"><span>    miniflare.setup.ts    # worker env config for tests</span></span>
<span class="line"><span>  _utils/</span></span>
<span class="line"><span>    test-server.ts        # ephemeral HTTP servers</span></span>
<span class="line"><span>    mock-fetch.ts         # Node fetch interception (Undici)</span></span>
<span class="line"><span>    log-capture.ts        # capture + assert logs</span></span></code></pre></div><p>Notes:</p><ul><li>The unit layer uses pure module-level tests with fetch mocked or local HTTP stubs.</li><li>Integration tests are black-box at module boundaries (e.g., ProtocolHandler + RequestRouter + mocks).</li><li>E2E spins the real Node server and/or Miniflare worker with realistic mocks for upstream MCP servers and OIDC.</li></ul><hr><h2 id="test-environment-management" tabindex="-1">Test Environment Management <a class="header-anchor" href="#test-environment-management" aria-label="Permalink to &quot;Test Environment Management&quot;">​</a></h2><ul><li><p>Node vs Workers selection</p><ul><li>Node-specific Vitest config: <code>vitest.config.ts</code> (environment: node)</li><li>Workers-specific Vitest config: <code>vitest.worker.config.ts</code> (environment: miniflare)</li><li>Test files can explicitly opt into Miniflare with <code>// @vitest-environment miniflare</code>.</li></ul></li><li><p>Isolation and determinism</p><ul><li>Use Vitest’s fake timers for retry/circuit tests.</li><li>Ephemeral HTTP servers: <code>tests/_utils/test-server.ts</code> binds to port 0 and auto-closes in <code>afterEach</code>.</li><li>Log capture: disable or capture logs via <code>Logger.configure({ json: true })</code> for stable assertions.</li></ul></li><li><p>Cross-platform resources</p><ul><li>OAuth flows invoke real HTTP endpoints; a mock OIDC provider runs as an in-process HTTP server in both Node and Miniflare scenarios (Miniflare tests remain in a Node host context, so spinning a Node HTTP stub is acceptable).</li><li>Upstream MCP backends emulated by <code>fake-backend</code> servers exposing <code>/capabilities</code>, <code>/mcp/tools/*</code>, <code>/mcp/resources/*</code>.</li></ul></li></ul><hr><h2 id="mock-and-stub-architecture" tabindex="-1">Mock and Stub Architecture <a class="header-anchor" href="#mock-and-stub-architecture" aria-label="Permalink to &quot;Mock and Stub Architecture&quot;">​</a></h2><h3 id="mcp-protocol-backends" tabindex="-1">MCP Protocol Backends <a class="header-anchor" href="#mcp-protocol-backends" aria-label="Permalink to &quot;MCP Protocol Backends&quot;">​</a></h3><ul><li>Fake backend servers respond with deterministic JSON: <ul><li><code>GET /capabilities</code>: lists tools/resources/prompts</li><li><code>POST /mcp/tools/list</code> and <code>/mcp/resources/list</code>: optional fallbacks</li><li><code>POST /mcp/tools/call</code>: echoes arguments or returns canned results</li><li><code>POST /mcp/resources/read</code>: returns fixture content</li></ul></li><li>Supports Bearer tokens to simulate auth propagation from Master.</li></ul><h3 id="oauth-provider-oidc-mock" tabindex="-1">OAuth Provider (OIDC) Mock <a class="header-anchor" href="#oauth-provider-oidc-mock" aria-label="Permalink to &quot;OAuth Provider (OIDC) Mock&quot;">​</a></h3><ul><li>Node HTTP server (Express or http module) serving: <ul><li><code>/.well-known/openid-configuration</code></li><li><code>/authorize</code>: simulates auth code issuance by redirecting with <code>code</code> + <code>state</code></li><li><code>/token</code>: returns JSON access token, optional refresh, scopes, <code>expires_in</code></li><li><code>/jwks.json</code>: JWKS for completeness if JOSE validation is later added upstream</li></ul></li><li>Uses <code>jose</code> to generate ephemeral key material and produce signed tokens if needed.</li><li>Configurable via factory helpers to tailor provider metadata per test.</li></ul><h3 id="http-mocking-for-node-optional" tabindex="-1">HTTP Mocking for Node (optional) <a class="header-anchor" href="#http-mocking-for-node-optional" aria-label="Permalink to &quot;HTTP Mocking for Node (optional)&quot;">​</a></h3><ul><li><code>undici</code> MockAgent helper when spinning HTTP servers is overkill.</li><li>Route by URL patterns and methods; fallback to network disallowed.</li></ul><hr><h2 id="test-data-management" tabindex="-1">Test Data Management <a class="header-anchor" href="#test-data-management" aria-label="Permalink to &quot;Test Data Management&quot;">​</a></h2><ul><li>Fixtures: JSON payloads for tools/resources/capabilities. Keep small and readable.</li><li>Factories: <ul><li><code>configFactory</code>: produce <code>MasterConfig</code> + <code>ServerConfig</code> with sensible defaults (ports, endpoints, auth strategies).</li><li><code>oauthFactory</code>: generate PKCE/state payloads and basic OAuth token shapes.</li><li><code>mcpFactory</code>: create tool/resource definitions and common requests.</li></ul></li><li>State/Token Stores: <ul><li>In-memory only; reset across tests.</li><li>If a persistent DB is introduced later: <ul><li>Node: use SQLite in-memory or Testcontainers in CI; provide cleanup hooks.</li><li>Workers: use Miniflare KV/D1 bindings with per-test namespaces.</li></ul></li></ul></li></ul><hr><h2 id="performance-testing-strategy-artillery" tabindex="-1">Performance Testing Strategy (Artillery) <a class="header-anchor" href="#performance-testing-strategy-artillery" aria-label="Permalink to &quot;Performance Testing Strategy (Artillery)&quot;">​</a></h2><ul><li>Scenarios: <ul><li>OAuth authorize/token (mock provider) happy-path latency and error rates.</li><li>Routing: <code>POST /mcp/tools/call</code> with mixed success/failure from backends to exercise retry/circuit logic.</li><li>Server lifecycle: parallel discovery calls to <code>/capabilities</code> against multiple backends.</li></ul></li><li>Metrics: <ul><li>p50/p90/p99 latency, RPS, error rates per route.</li><li>Custom logs via <code>Logger.time</code> around critical paths; scrape from structured logs when running locally.</li></ul></li><li>CI: <ul><li>Run on a separate “performance” workflow or on nightly schedules to avoid slowing PRs.</li></ul></li></ul><hr><h2 id="security-testing-architecture" tabindex="-1">Security Testing Architecture <a class="header-anchor" href="#security-testing-architecture" aria-label="Permalink to &quot;Security Testing Architecture&quot;">​</a></h2><ul><li>Property-based testing with <code>fast-check</code> for: <ul><li><code>FlowValidator.validateReturnTo</code>: ensure only safe origins/paths pass.</li><li><code>StateManager</code> and <code>PKCEManager</code>: state integrity, one-time consumption, and PKCE verifier binding.</li><li>Input validation for router requests (e.g., tool/resource names) using <code>utils/validation</code> helpers.</li></ul></li><li>OAuth flow protections: <ul><li>Ensure <code>state</code> is required and consumed exactly once.</li><li>Enforce PKCE method presence, verify rejection on mismatch.</li><li>Token exchange failure handling and error surface is sanitized.</li></ul></li><li>Optional dynamic scans: <ul><li>OWASP ZAP baseline against local server in CI (nightly) to catch obvious misconfigurations.</li></ul></li></ul><hr><h2 id="ci-cd-integration" tabindex="-1">CI/CD Integration <a class="header-anchor" href="#ci-cd-integration" aria-label="Permalink to &quot;CI/CD Integration&quot;">​</a></h2><h3 id="jobs" tabindex="-1">Jobs <a class="header-anchor" href="#jobs" aria-label="Permalink to &quot;Jobs&quot;">​</a></h3><ul><li>Lint + Typecheck: ESLint and <code>tsc -p tsconfig.node.json --noEmit</code>.</li><li>Unit + Integration (Node): Vitest with coverage.</li><li>Unit + Integration (Workers): Vitest (Miniflare) with coverage.</li><li>E2E: start local server; run black-box tests.</li><li>Security: property tests; optional ZAP baseline (nightly).</li><li>Performance: Artillery (nightly or gated by label).</li></ul><h3 id="coverage-and-quality-gates" tabindex="-1">Coverage and Quality Gates <a class="header-anchor" href="#coverage-and-quality-gates" aria-label="Permalink to &quot;Coverage and Quality Gates&quot;">​</a></h3><ul><li>Coverage via Vitest v8 provider; thresholds: <ul><li>Global: <code>branches: 80%</code>, <code>functions: 85%</code>, <code>lines: 85%</code>, <code>statements: 85%</code>.</li><li>Critical modules (routing, oauth): per-file <code>lines: 90%</code> target in follow-up.</li></ul></li><li>Fail PR job if thresholds not met.</li><li>Upload <code>lcov</code> or <code>cobertura</code> to CI artifacts (or Codecov if desired).</li></ul><hr><h2 id="test-utilities-integration-phase-8" tabindex="-1">Test Utilities Integration (Phase 8) <a class="header-anchor" href="#test-utilities-integration-phase-8" aria-label="Permalink to &quot;Test Utilities Integration (Phase 8)&quot;">​</a></h2><ul><li>Logger: <code>Logger.configure({ json: true, level: &#39;error&#39; })</code> in test setup; use <code>log-capture</code> to assert important events.</li><li>Validation: assert guards (<code>assertString</code>, <code>sanitizeObject</code>) across boundary tests; fuzz via fast-check.</li><li>Monitoring: wrap performance-critical test paths with <code>Logger.time</code> and assert upper bounds during perf runs.</li></ul><hr><h2 id="local-and-ci-usage" tabindex="-1">Local and CI Usage <a class="header-anchor" href="#local-and-ci-usage" aria-label="Permalink to &quot;Local and CI Usage&quot;">​</a></h2><ul><li><p>Local:</p><ul><li><code>vitest -c vitest.config.ts</code> for Node suites.</li><li><code>vitest -c vitest.worker.config.ts</code> for Worker suites.</li><li><code>artillery run tests/perf/artillery/auth-routing.yaml</code> for load tests.</li></ul></li><li><p>CI:</p><ul><li>Run jobs in parallel; collect coverage and artifacts.</li><li>Gate merges on lint, typecheck, unit/integration, and coverage.</li></ul></li></ul><hr><h2 id="next-steps-implementation-guide" tabindex="-1">Next Steps (Implementation Guide) <a class="header-anchor" href="#next-steps-implementation-guide" aria-label="Permalink to &quot;Next Steps (Implementation Guide)&quot;">​</a></h2><ol><li>Install dev deps: vitest, @vitest/coverage-v8, supertest, miniflare, artillery, fast-check, @types/supertest.</li><li>Add scripts: <code>test</code>, <code>test:node</code>, <code>test:workers</code>, <code>test:coverage</code>, <code>test:e2e</code>.</li><li>Fill factories and mocks with minimal working endpoints.</li><li>Seed initial critical tests: <ul><li>routing: circuit-breaker/retry/load-balancer</li><li>oauth: state, pkce, callback error handling</li><li>aggregator: discovery + mapping</li><li>protocol: call tool/resource happy path and error path</li></ul></li></ol>`,47)]))}const g=a(n,[["render",o]]);export{h as __pageData,g as default};
